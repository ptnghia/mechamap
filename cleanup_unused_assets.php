<?php
/**
 * MechaMap Assets Cleanup Tool
 * Script an to√†n ƒë·ªÉ x√≥a c√°c file assets kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng
 *
 * Usage:
 * php cleanup_unused_assets.php --dry-run          # Ch·ªâ hi·ªÉn th·ªã danh s√°ch
 * php cleanup_unused_assets.php --backup           # T·∫°o backup tr∆∞·ªõc khi x√≥a
 * php cleanup_unused_assets.php --force            # X√≥a th·ª±c s·ª±
 * php cleanup_unused_assets.php --restore          # Kh√¥i ph·ª•c t·ª´ backup
 */

class AssetsCleanupTool {
    private $basePath;
    private $backupPath;
    private $logFile;
    private $protectedAssets = [];
    private $usedAssets = [];
    private $allAssets = [];
    private $scanPaths = [];

    public function __construct() {
        $this->basePath = __DIR__;
        $this->backupPath = $this->basePath . '/assets_backup_' . date('Y-m-d_H-i-s');
        $this->logFile = $this->basePath . '/assets_cleanup.log';

        // ƒê·ªãnh nghƒ©a c√°c ƒë∆∞·ªùng d·∫´n c·∫ßn qu√©t
        $this->scanPaths = [
            'resources/views/',
            'public/js/',
            'resources/js/',
            'public/css/',
            'public/admin-sw.js',
            'public/sw.js',
            'public/manifest.json',
            'public/admin-manifest.json'
        ];

        // Assets ƒë∆∞·ª£c b·∫£o v·ªá - KH√îNG ƒë∆∞·ª£c x√≥a
        $this->protectedAssets = [
            // Core frameworks
            'assets/libs/bootstrap/',
            'assets/libs/jquery/',
            'assets/css/bootstrap',
            'assets/css/app',
            'assets/css/icons',
            'assets/js/app',

            // Admin essentials
            'assets/libs/apexcharts/',
            'assets/libs/datatables',
            'assets/libs/select2/',
            'assets/libs/metismenu/',
            'assets/libs/simplebar/',
            'assets/libs/node-waves/',

            // Fonts essentials
            'assets/fonts/fa-',
            'assets/fonts/materialdesignicons',

            // Core images
            'assets/images/favicon.ico',
            'assets/images/logo',
            'assets/images/icons/',

            // Custom files
            'assets/css/admin-mobile.css',
            'assets/css/hide-pwa-prompt.css',
            'assets/css/cart-ux-enhancements.css',
            'assets/js/admin-mobile.js',
            'assets/js/cart-ux-enhancements.js',
            'assets/js/mini-cart-enhancements.js',
            'assets/js/workflow-builder.js'
        ];
    }

    public function run($options = []) {
        $this->log("=== MechaMap Assets Cleanup Tool Started ===");
        $this->log("Time: " . date('Y-m-d H:i:s'));

        if (isset($options['restore'])) {
            return $this->restore();
        }

        // B∆∞·ªõc 1: Qu√©t t·∫•t c·∫£ assets
        $this->log("Step 1: Scanning all assets...");
        $this->scanAllAssets();

        // B∆∞·ªõc 2: T√¨m assets ƒë∆∞·ª£c s·ª≠ d·ª•ng
        $this->log("Step 2: Finding used assets...");
        $this->findUsedAssets();

        // B∆∞·ªõc 3: Ph√¢n t√≠ch v√† t·∫°o danh s√°ch x√≥a
        $this->log("Step 3: Analyzing unused assets...");
        $unusedAssets = $this->analyzeUnusedAssets();

        // B∆∞·ªõc 4: Hi·ªÉn th·ªã b√°o c√°o
        $this->displayReport($unusedAssets);

        // B∆∞·ªõc 5: Th·ª±c hi·ªán x√≥a (n·∫øu kh√¥ng ph·∫£i dry-run)
        if (!isset($options['dry-run'])) {
            if (isset($options['backup'])) {
                $this->createBackup($unusedAssets);
            }

            if (isset($options['force']) || $this->confirmAction()) {
                $this->deleteAssets($unusedAssets);
            }
        }

        $this->log("=== Cleanup Tool Finished ===");
    }

    private function scanAllAssets() {
        $assetsPath = $this->basePath . '/public/assets';
        $this->scanDirectory($assetsPath, 'assets');

        $this->log("Found " . count($this->allAssets) . " total assets");
    }

    private function scanDirectory($dir, $prefix = '') {
        if (!is_dir($dir)) return;

        $files = scandir($dir);
        foreach ($files as $file) {
            if ($file === '.' || $file === '..') continue;

            $fullPath = $dir . '/' . $file;
            $relativePath = $prefix . '/' . $file;

            if (is_dir($fullPath)) {
                $this->scanDirectory($fullPath, $relativePath);
            } else {
                $this->allAssets[] = [
                    'path' => ltrim($relativePath, '/'),
                    'fullPath' => $fullPath,
                    'size' => filesize($fullPath)
                ];
            }
        }
    }

    private function findUsedAssets() {
        foreach ($this->scanPaths as $path) {
            $fullPath = $this->basePath . '/' . $path;

            if (is_file($fullPath)) {
                $this->scanFile($fullPath);
            } elseif (is_dir($fullPath)) {
                $this->scanDirectoryForUsage($fullPath);
            }
        }

        $this->log("Found " . count($this->usedAssets) . " used assets");
    }

    private function scanDirectoryForUsage($dir) {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($dir)
        );

        foreach ($iterator as $file) {
            if (in_array($file->getExtension(), ['php', 'js', 'css', 'json'])) {
                $this->scanFile($file->getPathname());
            }
        }
    }

    private function scanFile($filePath) {
        if (!file_exists($filePath)) return;

        $content = file_get_contents($filePath);

        // T√¨m c√°c pattern kh√°c nhau
        $patterns = [
            '/assets\/[^\'"\s)}\]]+/',           // assets/path/file.ext
            '/asset\([\'"]([^\'")]+)[\'"]\)/',   // asset('path')
            '/url\([\'"]([^\'")]+)[\'"]\)/',     // url('path')
            '/"([^"]*assets[^"]*)"/',            // "path/assets/file"
            "/'([^']*assets[^']*)'/",            // 'path/assets/file'
        ];

        foreach ($patterns as $pattern) {
            preg_match_all($pattern, $content, $matches);

            foreach ($matches[0] as $match) {
                // L√†m s·∫°ch match
                $asset = trim($match, '"\'()');
                if (strpos($asset, 'assets/') !== false) {
                    // Chu·∫©n h√≥a path
                    if (strpos($asset, 'assets/') === 0) {
                        $this->usedAssets[] = $asset;
                    } else {
                        // Extract assets part
                        $pos = strpos($asset, 'assets/');
                        if ($pos !== false) {
                            $this->usedAssets[] = substr($asset, $pos);
                        }
                    }
                }
            }
        }
    }

    private function analyzeUnusedAssets() {
        $unused = [];

        foreach ($this->allAssets as $asset) {
            $assetPath = $asset['path'];

            // Ki·ªÉm tra xem c√≥ ƒë∆∞·ª£c b·∫£o v·ªá kh√¥ng
            if ($this->isProtected($assetPath)) {
                continue;
            }

            // Ki·ªÉm tra xem c√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng kh√¥ng
            $isUsed = false;
            foreach ($this->usedAssets as $used) {
                if (strpos($used, $assetPath) !== false ||
                    strpos($assetPath, str_replace('assets/', '', $used)) !== false) {
                    $isUsed = true;
                    break;
                }
            }

            if (!$isUsed) {
                $unused[] = $asset;
            }
        }

        return $unused;
    }

    private function isProtected($assetPath) {
        foreach ($this->protectedAssets as $protected) {
            if (strpos($assetPath, $protected) !== false) {
                return true;
            }
        }
        return false;
    }

    private function displayReport($unusedAssets) {
        echo "\n" . str_repeat("=", 80) . "\n";
        echo "           MECHAMAP ASSETS CLEANUP REPORT\n";
        echo str_repeat("=", 80) . "\n";

        $totalSize = array_sum(array_column($this->allAssets, 'size'));
        $unusedSize = array_sum(array_column($unusedAssets, 'size'));

        echo sprintf("üìä T·ªîNG QUAN:\n");
        echo sprintf("   ‚Ä¢ T·ªïng assets: %d files (%.2f MB)\n",
            count($this->allAssets), $totalSize / 1024 / 1024);
        echo sprintf("   ‚Ä¢ ƒêang s·ª≠ d·ª•ng: %d files\n",
            count($this->allAssets) - count($unusedAssets));
        echo sprintf("   ‚Ä¢ Kh√¥ng s·ª≠ d·ª•ng: %d files (%.2f MB)\n",
            count($unusedAssets), $unusedSize / 1024 / 1024);
        echo sprintf("   ‚Ä¢ Ti·∫øt ki·ªám ƒë∆∞·ª£c: %.1f%%\n\n",
            ($unusedSize / $totalSize) * 100);

        // Ph√¢n lo·∫°i theo th∆∞ m·ª•c
        $categories = $this->categorizeAssets($unusedAssets);

        echo "üìÅ PH√ÇN LO·∫†I FILE KH√îNG S·ª¨ D·ª§NG:\n";
        foreach ($categories as $category => $files) {
            $categorySize = array_sum(array_column($files, 'size'));
            echo sprintf("   ‚Ä¢ %s: %d files (%.2f MB)\n",
                $category, count($files), $categorySize / 1024 / 1024);
        }

        echo "\nüî¥ C√ÅC TH∆Ø VI·ªÜN L·ªöN C√ì TH·ªÇ X√ìA:\n";
        $this->displayLargeLibraries($unusedAssets);

        echo "\n‚ö†Ô∏è  C·∫¢NH B√ÅO:\n";
        echo "   ‚Ä¢ Lu√¥n t·∫°o backup tr∆∞·ªõc khi x√≥a\n";
        echo "   ‚Ä¢ Test k·ªπ sau khi x√≥a\n";
        echo "   ‚Ä¢ M·ªôt s·ªë assets c√≥ th·ªÉ ƒë∆∞·ª£c load ƒë·ªông\n";

        echo "\n" . str_repeat("=", 80) . "\n";
    }

    private function categorizeAssets($assets) {
        $categories = [];

        foreach ($assets as $asset) {
            $path = $asset['path'];

            if (strpos($path, 'assets/libs/') === 0) {
                $lib = explode('/', $path)[2];
                $categories["Th∆∞ vi·ªán: $lib"][] = $asset;
            } elseif (strpos($path, 'assets/css/') === 0) {
                $categories['CSS Files'][] = $asset;
            } elseif (strpos($path, 'assets/js/') === 0) {
                $categories['JavaScript Files'][] = $asset;
            } elseif (strpos($path, 'assets/images/') === 0) {
                $categories['Images'][] = $asset;
            } elseif (strpos($path, 'assets/fonts/') === 0) {
                $categories['Fonts'][] = $asset;
            } else {
                $categories['Other'][] = $asset;
            }
        }

        return $categories;
    }

    private function displayLargeLibraries($unusedAssets) {
        $libraries = [];

        foreach ($unusedAssets as $asset) {
            if (strpos($asset['path'], 'assets/libs/') === 0) {
                $lib = explode('/', $asset['path'])[2];
                if (!isset($libraries[$lib])) {
                    $libraries[$lib] = ['count' => 0, 'size' => 0];
                }
                $libraries[$lib]['count']++;
                $libraries[$lib]['size'] += $asset['size'];
            }
        }

        // S·∫Øp x·∫øp theo size
        uasort($libraries, function($a, $b) {
            return $b['size'] - $a['size'];
        });

        $largeLibs = array_slice($libraries, 0, 10, true);
        foreach ($largeLibs as $lib => $info) {
            if ($info['size'] > 100000) { // > 100KB
                echo sprintf("   ‚Ä¢ %s: %d files (%.2f MB)\n",
                    $lib, $info['count'], $info['size'] / 1024 / 1024);
            }
        }
    }

    private function createBackup($unusedAssets) {
        echo "\nüîÑ T·∫°o backup...\n";

        if (!mkdir($this->backupPath, 0755, true)) {
            throw new Exception("Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c backup: " . $this->backupPath);
        }

        $backupList = [];

        foreach ($unusedAssets as $asset) {
            $sourcePath = $asset['fullPath'];
            $relativePath = $asset['path'];
            $backupFilePath = $this->backupPath . '/' . $relativePath;

            // T·∫°o th∆∞ m·ª•c con n·∫øu c·∫ßn
            $backupDir = dirname($backupFilePath);
            if (!is_dir($backupDir)) {
                mkdir($backupDir, 0755, true);
            }

            // Copy file
            if (copy($sourcePath, $backupFilePath)) {
                $backupList[] = $relativePath;
            }
        }

        // T·∫°o file manifest cho backup
        $manifest = [
            'created_at' => date('Y-m-d H:i:s'),
            'total_files' => count($backupList),
            'files' => $backupList
        ];

        file_put_contents($this->backupPath . '/manifest.json',
            json_encode($manifest, JSON_PRETTY_PRINT));

        echo "‚úÖ Backup ho√†n th√†nh: " . $this->backupPath . "\n";
        echo "   ƒê√£ backup " . count($backupList) . " files\n";

        $this->log("Backup created: " . $this->backupPath);
    }

    private function deleteAssets($unusedAssets) {
        echo "\nüóëÔ∏è  B·∫Øt ƒë·∫ßu x√≥a assets...\n";

        $deleted = 0;
        $errors = 0;
        $totalSize = 0;

        foreach ($unusedAssets as $asset) {
            $filePath = $asset['fullPath'];

            if (file_exists($filePath)) {
                if (unlink($filePath)) {
                    $deleted++;
                    $totalSize += $asset['size'];
                    $this->log("Deleted: " . $asset['path']);

                    // Hi·ªÉn th·ªã progress
                    if ($deleted % 50 == 0) {
                        echo "   ƒê√£ x√≥a $deleted files...\n";
                    }
                } else {
                    $errors++;
                    $this->log("ERROR: Cannot delete " . $asset['path']);
                }
            }
        }

        // X√≥a th∆∞ m·ª•c r·ªóng
        $this->removeEmptyDirectories($this->basePath . '/public/assets');

        echo "\n‚úÖ Ho√†n th√†nh:\n";
        echo "   ‚Ä¢ ƒê√£ x√≥a: $deleted files\n";
        echo "   ‚Ä¢ L·ªói: $errors files\n";
        echo "   ‚Ä¢ Ti·∫øt ki·ªám: " . number_format($totalSize / 1024 / 1024, 2) . " MB\n";

        $this->log("Cleanup completed: $deleted deleted, $errors errors");
    }

    private function removeEmptyDirectories($dir) {
        if (!is_dir($dir)) return;

        $files = scandir($dir);
        $hasFiles = false;

        foreach ($files as $file) {
            if ($file === '.' || $file === '..') continue;

            $fullPath = $dir . '/' . $file;
            if (is_dir($fullPath)) {
                $this->removeEmptyDirectories($fullPath);
                if (is_dir($fullPath) && count(scandir($fullPath)) == 2) {
                    rmdir($fullPath);
                    $this->log("Removed empty directory: " . $fullPath);
                } else {
                    $hasFiles = true;
                }
            } else {
                $hasFiles = true;
            }
        }
    }

    private function restore() {
        echo "üîÑ Kh√¥i ph·ª•c t·ª´ backup...\n";

        // T√¨m backup g·∫ßn nh·∫•t
        $backupDirs = glob($this->basePath . '/assets_backup_*');
        if (empty($backupDirs)) {
            echo "‚ùå Kh√¥ng t√¨m th·∫•y backup n√†o!\n";
            return false;
        }

        // S·∫Øp x·∫øp theo th·ªùi gian
        rsort($backupDirs);
        $latestBackup = $backupDirs[0];

        echo "S·ª≠ d·ª•ng backup: " . basename($latestBackup) . "\n";

        // ƒê·ªçc manifest
        $manifestPath = $latestBackup . '/manifest.json';
        if (!file_exists($manifestPath)) {
            echo "‚ùå Kh√¥ng t√¨m th·∫•y manifest file!\n";
            return false;
        }

        $manifest = json_decode(file_get_contents($manifestPath), true);

        echo "Kh√¥i ph·ª•c " . $manifest['total_files'] . " files...\n";

        $restored = 0;
        foreach ($manifest['files'] as $file) {
            $backupFile = $latestBackup . '/' . $file;
            $targetFile = $this->basePath . '/public/' . $file;

            // T·∫°o th∆∞ m·ª•c n·∫øu c·∫ßn
            $targetDir = dirname($targetFile);
            if (!is_dir($targetDir)) {
                mkdir($targetDir, 0755, true);
            }

            if (copy($backupFile, $targetFile)) {
                $restored++;
            }
        }

        echo "‚úÖ ƒê√£ kh√¥i ph·ª•c $restored files\n";
        $this->log("Restored $restored files from backup: $latestBackup");

        return true;
    }

    private function confirmAction() {
        echo "\n‚ö†Ô∏è  B·∫†N C√ì CH·∫ÆC CH·∫ÆN MU·ªêN X√ìA C√ÅC FILE N√ÄY?\n";
        echo "Nh·∫≠p 'yes' ƒë·ªÉ x√°c nh·∫≠n: ";

        $handle = fopen("php://stdin", "r");
        $input = trim(fgets($handle));
        fclose($handle);

        return strtolower($input) === 'yes';
    }

    private function log($message) {
        $logMessage = "[" . date('Y-m-d H:i:s') . "] " . $message . "\n";
        file_put_contents($this->logFile, $logMessage, FILE_APPEND);

        // C≈©ng hi·ªÉn th·ªã trong console n·∫øu l√† debug
        if (defined('DEBUG') && DEBUG) {
            echo $logMessage;
        }
    }
}

// Command line interface
function showUsage() {
    echo "MechaMap Assets Cleanup Tool\n";
    echo "Usage: php cleanup_unused_assets.php [options]\n\n";
    echo "Options:\n";
    echo "  --dry-run     Ch·ªâ hi·ªÉn th·ªã danh s√°ch, kh√¥ng x√≥a th·ª±c s·ª±\n";
    echo "  --backup      T·∫°o backup tr∆∞·ªõc khi x√≥a\n";
    echo "  --force       X√≥a m√† kh√¥ng c·∫ßn x√°c nh·∫≠n\n";
    echo "  --restore     Kh√¥i ph·ª•c t·ª´ backup g·∫ßn nh·∫•t\n";
    echo "  --help        Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n n√†y\n\n";
    echo "Examples:\n";
    echo "  php cleanup_unused_assets.php --dry-run\n";
    echo "  php cleanup_unused_assets.php --backup --force\n";
    echo "  php cleanup_unused_assets.php --restore\n";
}

// Main execution
if (php_sapi_name() !== 'cli') {
    die("Script n√†y ch·ªâ ch·∫°y ƒë∆∞·ª£c t·ª´ command line!\n");
}

$options = [];
$args = array_slice($argv, 1);

foreach ($args as $arg) {
    if ($arg === '--help') {
        showUsage();
        exit(0);
    }

    $options[ltrim($arg, '-')] = true;
}

if (empty($options)) {
    echo "‚ö†Ô∏è  Kh√¥ng c√≥ option n√†o ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh. Ch·∫°y v·ªõi --dry-run ƒë·ªÉ xem tr∆∞·ªõc.\n";
    echo "S·ª≠ d·ª•ng --help ƒë·ªÉ xem h∆∞·ªõng d·∫´n.\n";
    exit(1);
}

try {
    $tool = new AssetsCleanupTool();
    $tool->run($options);
} catch (Exception $e) {
    echo "‚ùå L·ªói: " . $e->getMessage() . "\n";
    exit(1);
}
